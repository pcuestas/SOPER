\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{fancyvrb}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{codewhite}{rgb}{1,1,1}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple},
    numberstyle=\tiny\color{codewhite},
    stringstyle=\color{magenta},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{
    style=mystyle
}

\pagestyle{fancy}
\fancyhf{}
\rhead{Sistemas Operativos. Práctica 1.}
\lhead{Pablo Cuesta y Álvaro Zamanillo}
\cfoot{\thepage}


\usepackage{xcolor}   %May be necessary if you want to color links
\usepackage{hyperref}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
}

\title{Sistemas Operativos. Práctica 1.}
\author{Pablo Cuesta Sierra y Álvaro Zamanillo Sáez }
\date{}





\begin{document}

\maketitle

%\tableofcontents

\section*{Semana 1}
\subsection*{Ejercicio 1}

a) Para buscar las funciones relacionadas con hilos, buscamos todas aquellas que contengan ``pthread'' usando la opción -k en el comando man. El comando a usar es: 

\begin{lstlisting}[language=bash]
$ man -k pthread
\end{lstlisting}

Lista de funciones resultante: 

\lstinputlisting[breaklines]{pthread_functions.txt}

b) Consultar en el manual en qué sección se encuentran las llamadas a sistema y buscar infromación sobre write:

\begin{lstlisting}[language=bash]
$ man man
\end{lstlisting}

Con este comando averiguamos que la sección relacionada a \textit{system calls} es la 2. Por lo tanto usamos el comando:

\begin{lstlisting}[language=bash]
$ man 2 write
\end{lstlisting}

\subsection*{Ejercico 2}


a) El comando empleado es: 

\begin{lstlisting}[language=bash]
$ grep -w molino "don quijote.txt" >> aventuras.txt
\end{lstlisting}

Usamos el comando grep para buscar las apariciones de ``molino''. Como queremos que sea la palabra \textit{molino} y no el grama \textit{molino}, añadimos la opción \texttt{-w}. Finalmente redireccionamos la salida con \texttt {>}\texttt {>} en vez de \texttt {>} para que se añada al final del fichero, en lugar de reemplazarlo.

b) El \textit{pipeline} es el siguiente:

\begin{lstlisting}[language=bash]
$ ls | wc -l
\end{lstlisting}

La salida de \texttt{ls} es una lista (fichero) con los ficheros del actual directorio.
Esta lista la usamos como input del comando wc, que acompañado de la opción -l, cuenta las lineas de dicha lista.


c) En este caso el \textit{pipeline} es: 

\begin{lstlisting}[language=bash]
$ cat "lista de la compra Pepe.txt" "lista de la compra Elena.txt" 2> /dev/null | sort | uniq | wc -l > "num compra.txt"
\end{lstlisting}

Primero concatenamos los dos ficheros (redirigiendo el mensaje error, en caso de haberlo). Después, dirigimos la salida para que sea el input de \texttt{sort}, para que luego \texttt{uniq} quite las líneas repetidas. Finalmente, contamos el número de líneas distintas con \texttt{wc -l} y dirigimos la salida al fichero \texttt{"num compra.txt"}.

\subsection*{Ejercicio 3}

a) Si intentamos abrir un fichero inexistente recibimos el mensanje \texttt{"No such file or directory"}. El código errno asociado es 2.

b) En el caso de intentar abrir el fichero /etc/shadow el  mensaje de error es \texttt{"Permission denied"}, que corresponde al valor de errno 13.

c) Justo después de la instrucción \texttt{fopen()} se debería guardar el valor de errno en otra variable ya que la llamada a \texttt{printf()} podría modificar la variable global errno.

\begin{lstlisting}[language=C]
pf=fopen(args[1],"r"); 
x=errno;
printf("El valor de errno es %i",x);
errno=x; /*Aqu\`i aseguramos que la funci\`on perror() va a imprimir el c\`odigo de error de fopen ya que hemos restaurado el valor de errno asociado a fopen()*/
perror();
\end{lstlisting}


\subsection*{Ejercicio 4}

a) Durante los 10 segundos de espera el proceso asociado al programa está en estado ``R''(runnable), es decir se está ejecutando (intercalándose con otros).

b) En este caso el proceso está en estado ``S'' (interruptible sleep) o lo que es lo mismo, esperando a un suceso (el fin de la espera marcada por sleep()), mientras se ejecutan otros procesos.


\subsection*{Ejercicio 5}\label{ej5}

a) Si el proceso no hubiese esperado a los hilos, cuando el hilo principal llegase a \texttt{exit()}, el programa finalizaría matando los hilos que no tendrían por qué haber acabado. De hecho, si quitamos del código las instrucciones \texttt{pthread\_join}, vemos que cada hilo solo tiene tiempo de escribir una letra antes de que el hilo principal llegue al exit y finalice, por tanto, la ejecución de todos los hilos.

b) En este caso, ocurre exactamente lo mismo que en anterior (se imprimen las dos primeras letras--una de cada hilo--, luego se imprime el mensaje de la línea 51 en el código dado). Sin embargo, después de esto, continúan ejecutándose los dos hilos hasta que cada uno de ellos llega a su función \texttt{exit()}.

Es decir, \texttt{pthread\_exit()} termina la ejecución del hilo principal, pero permite que se terminen todos los hilos que del proceso antes de terminarlo. Lo cual no pasa si se llama directamente a \texttt{exit()}, como hemos visto en el apratado 5a).

c) Para que los otros hilos puedan terminar su ejecución, tenemos que sustituir la llamada en \texttt{main()} de \texttt{exit()} por una llamada a \texttt{pthread\_exit()}.



\end{document}











%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Verbatim}[frame=single]
cosas
\end{Verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[h]
\caption{Search 8.}
\bigskip
\includegraphics[scale=0.4]{ser8}
\centering
\label{fig:ser8}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{magenta},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C]
bool findKey(const char * book_id, const char *indexName, int * nodeIDOrDataOffset){
    FILE *pf=NULL;
    int pos, comp;
    Node node;
    bool found = false;
    char b_id[5], search[5];

    if(!indexName)
        return false;

    if((pf=fopen(indexName,"rb"))==NULL)
        return false;

    memcpy(search, book_id, PK_SIZE);
    search[PK_SIZE] = '\0';
    /*read the root's position*/
    fread(&pos, sizeof(int), 1, pf);

    if(pos==-1){/*empty*/
        *nodeIDOrDataOffset=-1;
    }

    while(pos != -1 && found == false){
        /*find the node's offset in the file*/
        fseek(pf, INDEX_HEADER_SIZE+pos*sizeof(Node), SEEK_SET);
        /*read the node*/
        fread(&node, sizeof(Node), 1, pf);
        memcpy(b_id, node.book_id, PK_SIZE);
        b_id[PK_SIZE] = '\0';
        /*compare the primary key*/
        comp=strcmp(search, b_id);
        
        if(comp < 0){
            if(node.left==-1)/*not found*/
                (*nodeIDOrDataOffset) = pos;
            pos = node.left;            
        }
        else if(comp > 0){
            if(node.right==-1)/*not found*/
                (*nodeIDOrDataOffset) = pos;
            pos = node.right;            
        }
        else{/*found*/
            (*nodeIDOrDataOffset) = node.offset;
            found = true;
        }
    }
    fclose(pf);
    return found;
}

\end{lstlisting}


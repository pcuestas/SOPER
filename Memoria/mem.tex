\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{fancyvrb}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{codewhite}{rgb}{1,1,1}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple},
    numberstyle=\tiny\color{codewhite},
    stringstyle=\color{magenta},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{
    style=mystyle
}

\pagestyle{fancy}
\fancyhf{}
\rhead{Sistemas Operativos. Práctica 1.}
\lhead{Pablo Cuesta y Álvaro Zamanillo}
\cfoot{\thepage}


\usepackage{xcolor}   %May be necessary if you want to color links
\usepackage{hyperref}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
}

\title{Sistemas Operativos. Práctica 1.}
\author{Pablo Cuesta Sierra y Álvaro Zamanillo Sáez }
\date{}





\begin{document}

\maketitle

%\tableofcontents

\section*{Semana 1}
\subsection*{Ejercicio 1}

a) Para buscar las funciones relacionadas con hilos, buscamos todas aquellas que contengan ``pthread'' usando la opción -k en el comando man. El comando a usar es: 

\begin{lstlisting}[language=bash]
$ man -k pthread
\end{lstlisting}

Lista de funciones resultante: 

\lstinputlisting[breaklines]{pthread_functions.txt}

b) Consultar en el manual en qué sección se encuentran las llamadas a sistema y buscar infromación sobre write:

\begin{lstlisting}[language=bash]
$ man man
\end{lstlisting}

Con este comando averiguamos que la sección relacionada a \textit{system calls} es la 2. Por lo tanto usamos el comando:

\begin{lstlisting}[language=bash]
$ man 2 write
\end{lstlisting}

\subsection*{Ejercico 2}


a) El comando empleado es: 

\begin{lstlisting}[language=bash]
$ grep -w molino "don quijote.txt" >> aventuras.txt
\end{lstlisting}

Usamos el comando grep para buscar las apariciones de ``molino''. Como queremos que sea la palabra \textit{molino} y no el grama \textit{molino}, añadimos la opción \texttt{-w}. Finalmente redireccionamos la salida con \texttt {>}\texttt {>} en vez de \texttt {>} para que se añada al final del fichero, en lugar de reemplazarlo.

b) El \textit{pipeline} es el siguiente:

\begin{lstlisting}[language=bash]
$ ls | wc -l
\end{lstlisting}

La salida de \texttt{ls} es una lista (fichero) con los ficheros del actual directorio.
Esta lista la usamos como input del comando wc, que acompañado de la opción -l, cuenta las lineas de dicha lista.


c) En este caso el \textit{pipeline} es: 

\begin{lstlisting}[language=bash]
$ cat "lista de la compra Pepe.txt" "lista de la compra Elena.txt" 2> /dev/null | sort | uniq | wc -l > "num compra.txt"
\end{lstlisting}

Primero concatenamos los dos ficheros (redirigiendo el mensaje error, en caso de haberlo). Después, dirigimos la salida para que sea el input de \texttt{sort}, para que luego \texttt{uniq} quite las líneas repetidas. Finalmente, contamos el número de líneas distintas con \texttt{wc -l} y dirigimos la salida al fichero \texttt{"num compra.txt"}.

\subsection*{Ejercicio 3}

a) Si intentamos abrir un fichero inexistente recibimos el mensanje \texttt{"No such file or directory"}. El código errno asociado es 2.

b) En el caso de intentar abrir el fichero /etc/shadow el  mensaje de error es \texttt{"Permission denied"}, que corresponde al valor de errno 13.

c) Justo después de la instrucción \texttt{fopen()} se debería guardar el valor de errno en otra variable ya que la llamada a \texttt{printf()} podría modificar la variable global errno.

\begin{lstlisting}[language=C]
pf=fopen(args[1],"r"); 
x=errno;
printf("El valor de errno es %i",x);
errno=x; /*Aqu\`i aseguramos que la funci\`on perror() va a imprimir el c\`odigo de error de fopen ya que hemos restaurado el valor de errno asociado a fopen()*/
perror();
\end{lstlisting}


\subsection*{Ejercicio 4}

a) Durante los 10 segundos de espera el proceso asociado al programa está en estado ``R''(runnable), es decir se está ejecutando (intercalándose con otros).

b) En este caso el proceso está en estado ``S'' (interruptible sleep) o lo que es lo mismo, esperando a un suceso (el fin de la espera marcada por sleep()), mientras se ejecutan otros procesos.


\subsection*{Ejercicio 5}\label{ej5}

a) Si el proceso no hubiese esperado a los hilos, cuando el hilo principal llegase a \texttt{exit()}, el programa finalizaría matando los hilos que no tendrían por qué haber acabado. De hecho, si quitamos del código las instrucciones \texttt{pthread\_join}, vemos que cada hilo solo tiene tiempo de escribir una letra antes de que el hilo principal llegue al exit y finalice, por tanto, la ejecución de todos los hilos.

b) En este caso, ocurre exactamente lo mismo que en anterior (se imprimen las dos primeras letras--una de cada hilo--, luego se imprime el mensaje de la línea 51 en el código dado). Sin embargo, después de esto, continúan ejecutándose los dos hilos hasta que cada uno de ellos llega a su función \texttt{exit()}.

Es decir, \texttt{pthread\_exit()} termina la ejecución del hilo principal, pero permite que se terminen todos los hilos que del proceso antes de terminarlo. Lo cual no pasa si se llama directamente a \texttt{exit()}, como hemos visto en el apratado 5a).

c) Para que los otros hilos puedan terminar su ejecución, tenemos que sustituir la llamada en \texttt{main()} de \texttt{exit()} por una llamada a \texttt{pthread\_exit()}.

\subsection*{Ejercicio 6}

a) No se puede saber ya que después de cada \texttt{fork()} el planificador puede establecer que el proceso padre siga en ejecución o su hijo.

b) Como queremos que sea el hijo el que imprima su PID y el de su padre, hay que modificar el bloque if correspondiente al hijo (\texttt{fork()} devuelve 0 en el hijo). En el printf llamamos a las funciones \texttt{getpid()} y \texttt{gepppid()} haciendo cast de sus valores de retorno.

c) El código se corresponde al diagrama a) ya que los hijos depués de imprimir acaban (llamada a \texttt{exit()}) y en cambio el padre vuelve a crear un nuevo hijo en la siguiente iteración. Para obtener el otro diagrama habría que hacer los bloques de control simétricos; el proceso padre es el que llama a \texttt{exit()} y el hijo es el que crea un nuevo proceso (y se convierte en padre).

d) El código original puede dejar huérfanos ya que nada asegura que sus 3 hijos vayan a finalizar antes que él. En cuanto el proceso padre se encuentre en la línea de ejecución del \texttt{wait()} y un hijo suyo finalice, el proceso padre finalizará también dejando huérfano a los posibles hijos restantes. 

e) Una forma de evitar esto es cambiar esa línea de código por la siguiente expresión \texttt{while(wait()!=-1);} que hará NUM\_PROC \textit{waits} y el siguiente retornará -1 al no haber procesos hijos no esperados (\textit{unwaited-for children}) 

\subsection*{Ejercicio 7}

a) Al ejecutar vemos que la cadena \textit{sentence} que imprime el padre está vacía. El error del programa es no teneer en cuenta que al crear el proceso hijo, éste tiene una memoria separada del padre  por lo que los cambios que se hagan desde el hijo no son visibles desde el padre. Cada puntero \textit{sentence} apunta a una dirección de memoria distinta.
(debido al \textit{Copy on write} podría ser que si no se trata de modificar la información de ese bloque de memoria no se llegase a crear una copia. No obstante en este caso no hay dudas ya que estamos modificando la memoria apuntada por \textit{sentence} al llamar a la función \texttt{strcpy()}).

b) Habría que liberar memoria tanto en el padre como en el hijo ya que se está creando una nueva copia del bloque de memoria alocado en el proceso padre como hemos explicado en el apartado anterior.


\subsection*{Ejercicio 8}


\end{document}











%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{Verbatim}[frame=single]
cosas
\end{Verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[h]
\caption{Search 8.}
\bigskip
\includegraphics[scale=0.4]{ser8}
\centering
\label{fig:ser8}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{magenta},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lstlisting}[language=C]
bool findKey(const char * book_id, const char *indexName, int * nodeIDOrDataOffset){
    FILE *pf=NULL;
    int pos, comp;
    Node node;
    bool found = false;
    char b_id[5], search[5];

    if(!indexName)
        return false;

    if((pf=fopen(indexName,"rb"))==NULL)
        return false;

    memcpy(search, book_id, PK_SIZE);
    search[PK_SIZE] = '\0';
    /*read the root's position*/
    fread(&pos, sizeof(int), 1, pf);

    if(pos==-1){/*empty*/
        *nodeIDOrDataOffset=-1;
    }

    while(pos != -1 && found == false){
        /*find the node's offset in the file*/
        fseek(pf, INDEX_HEADER_SIZE+pos*sizeof(Node), SEEK_SET);
        /*read the node*/
        fread(&node, sizeof(Node), 1, pf);
        memcpy(b_id, node.book_id, PK_SIZE);
        b_id[PK_SIZE] = '\0';
        /*compare the primary key*/
        comp=strcmp(search, b_id);
        
        if(comp < 0){
            if(node.left==-1)/*not found*/
                (*nodeIDOrDataOffset) = pos;
            pos = node.left;            
        }
        else if(comp > 0){
            if(node.right==-1)/*not found*/
                (*nodeIDOrDataOffset) = pos;
            pos = node.right;            
        }
        else{/*found*/
            (*nodeIDOrDataOffset) = node.offset;
            found = true;
        }
    }
    fclose(pf);
    return found;
}

\end{lstlisting}

